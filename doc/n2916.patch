--- doc/P2528R0.md	2022-01-22 15:03:34.374093280 +0100
+++ doc/n2916.md	2022-01-23 22:31:03.605443586 +0100
@@ -1,10 +1,9 @@
-    C++ Identifier Security using Unicode Standard Annex 39
+    n2916 - C Identifier Security using Unicode Standard Annex 39
 
-    Document #: P2538R0
     Date:       2022-01-22
-    Project:    Programming Language C++
-    Audience:   EWG
-                CWG
+    Project:    Programming Language C
+    Audience:   WG14
+                SG-16
     Reply-to:   Reini Urban <reini.urban@gmail.com>
 
 1 Abstract
@@ -12,7 +11,7 @@
 
 In response to [P1949R7](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1949r7.html)
 
-Adopt Unicode Annex 39 "Unicode Security Mechanisms" as part of C++23.
+Adopt Unicode Annex 39 "Unicode Security Mechanisms" as part of C23.
 
 * Comply to a variant of [TR39#5.2](https://www.unicode.org/reports/tr39/#Restriction_Level_Detection)
   Mixed-Scripts Moderately Restrictive profile, but allow some Greek letters without
@@ -35,7 +34,7 @@
 Recommend binutils/linker ABI identifier rules: names are UTF-8,
 add add identifier checks. E.g. `readelf -L -Ue`.
 
-In addition adopt this proposal as a Defect Report against C++20 and
+In addition adopt this proposal as a Defect Report against C11 and
 earlier. The author provides the
 [libu8ident](https://github.com/rurban/libu8ident/) library (Apache 2
 licensed) and its generated tables to all implementors.
@@ -73,7 +72,7 @@
 as they appeared in browsers and email. Also names in C object files:
 linkers, .def files, ffi's.
 
-Implementing TR39 mixed script detection per document (C++ Header and
+Implementing TR39 mixed script detection per document (C Header and
 Source file) forbids insecure mixes of Greek with Cyrillic, dangerous
 Arabic RTL bidi attacks and most confusables. You can still write in
 your language, but then only in commonly written languages, and not
@@ -170,7 +169,7 @@
 4.3 Documents with identifiers in many multiple scripts/languages will become illegal
 -------------------------------------------------------------------------------------
 
-C++23 (and C23) will follow the TR39 Security Profile 4 **Moderately
+C23 (and C23++) will follow the TR39 Security Profile 4 **Moderately
 Restrictive**, with an exception for Greek.
 
 * All identifiers in a document qualify as Single Script, or
@@ -247,7 +246,7 @@
 7.1 SC
 -----
 
-C++ only needs to map unicode characters to a script property via a
+C only needs to map unicode characters to a script property via a
 single byte.  There are currently 161 scripts assigned, 32 of them are
 in common use as identifiers, hence called **Recommended** scripts. The
 rest is split up into 127-31 **Excluded** scripts, which are not in common
@@ -487,12 +486,14 @@
              Greek confusable
 * U+03F2 ( ϲ → c ) GREEK LUNATE SIGMA SYMBOL → LATIN SMALL LETTER C
              Greek confusable
+* U+0381 ; ( α → a ) GREEK SMALL LETTER ALPHA. Not confusable
+* U+03F1 ; ( ϱ → p ) GREEK RHO SYMBOL → LATIN SMALL LETTER P. Not confusable
 
 TR39 also compiles a convenient
 [IdentifierStatus](https://www.unicode.org/Public/security/latest/IdentifierStatus.txt)
 list. But all the math letters with Script=Common from U+2100 to
 U+2200 are restricted, as Greek is forbidden mixed with Latin in the
-original TR39 Moderately Restrictive profile. Most are allowed
+original TR39 Moderately Restrictive profile. These are allowed
 according to the TR31 and TR39 rules of SAFEC23, so we need to come up
 with our own list of `XID_Start/XID_Continue` codepoints, excluding
 the Limited Use and Excluded scripts. And if an implementation choses
@@ -520,11 +521,11 @@
 identifiers.  One could argue that a mixed-script profile is valid
 only for a single identifier, or it is valid for the whole source file
 document. And there needs to be a definition if before or after the
-preprocessor, and if to treat names in private structs and classes as
-seperate contexts.
+preprocessor, and if to treat names in private structs as seperate
+contexts.
 
 If valid for only a single identifier you could arbitralily mix up
-Cyrillic with Greek identifiers in a C++ namespace, and thus these
+Cyrillic with Greek identifiers in a C files, and thus these
 identifiers would not be identifiable anymore, as both both can render
 to the very same glyphs. Thus we adopt the notion of identifier
 contexts.
@@ -561,9 +562,9 @@
 - **private**: Another argument would be that all exported names end
   up in the object files and library flat, which would support the
   seperation of private and public name contexts, where to perform the
-  mixed-script checks. Private contexts (e.g. static structs or
-  private class fields) should be seperated from the rest.  This would
-  prevent from confusuables in struct/class fields/methods, and the
+  mixed-script checks. Private contexts (e.g. static structs fields)
+  should be seperated from the rest.  This would
+  prevent from confusables in struct fields/methods, and the
   rest is seperated by the checks for the public names.
 
 - **after-cpp**: The third, strictest variant would define the context in
@@ -607,7 +608,7 @@
 12 Issues with binutils, linkers, exported identifiers
 =====================================================
 
-The crux with C and somewhat also C++ identifiers, is that they can be
+The crux with C and somewhat also C identifiers, is that they can be
 used with other earlier compilers or languages without any unicode security
 profile or restriction. ffi's are very common, libraries or .def files
 even more, thanksfully unicode names not at all yet.
@@ -617,15 +618,15 @@
 there, and names are charset (=user) specific, whilst there are no header
 fields for the used charset (e.g. if SHIFT-JIS or UTF-8), nor are
 there any rules for name lookup (normalization). This is not solvable
-here (in C nor C++), only there. Only in the Rust ecosystem there are
-proper unicode identifier rules, but Rust can link against
-C++/C. I haven't detected any exported unicode names in the wild, they
+here (in C), only there. Only in the Rust ecosystem there are
+proper unicode identifier rules, but Rust can link against C.
+I haven't detected any exported unicode names in the wild, they
 are only used in local symbols still. UTF-16 compilers such as MSVC do
 export their UNICODE names either in the local character set or as
 UTF-8. If used wildly, object files would not link anymore, as local
 character sets vary, and there is no character set standard defined.
 
-The C++/C working groups should urge the binutils/linker working
+The C/C++ working groups should urge the binutils/linker working
 groups to adopt a more precise specification how exported identifiers
 are represented in object files and libraries: UTF-8 or any charset,
 and how they are looked up: any normalization, NFC or not at all.  My
