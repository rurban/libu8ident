--- doc/P2528R0.md	2022-01-22 15:03:34.374093280 +0100
+++ doc/n2916.md	2022-01-24 08:08:28.905760328 +0100
@@ -1,10 +1,9 @@
-    C++ Identifier Security using Unicode Standard Annex 39
+    n2916 - C Identifier Security using Unicode Standard Annex 39
 
-    Document #: P2538R0
     Date:       2022-01-22
-    Project:    Programming Language C++
-    Audience:   EWG
-                CWG
+    Project:    Programming Language C
+    Audience:   WG14
+                SG-16
     Reply-to:   Reini Urban <reini.urban@gmail.com>
 
 1 Abstract
@@ -12,7 +11,7 @@
 
 In response to [P1949R7](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1949r7.html)
 
-Adopt Unicode Annex 39 "Unicode Security Mechanisms" as part of C++23.
+Adopt Unicode Annex 39 "Unicode Security Mechanisms" as part of C23.
 
 * Comply to a variant of [TR39#5.2](https://www.unicode.org/reports/tr39/#Restriction_Level_Detection)
   Mixed-Scripts Moderately Restrictive profile, but allow some Greek letters without
@@ -35,7 +34,7 @@
 Recommend binutils/linker ABI identifier rules: names are UTF-8,
 add add identifier checks. E.g. `readelf -L -Ue`.
 
-In addition adopt this proposal as a Defect Report against C++20 and
+In addition adopt this proposal as a Defect Report against C11 and
 earlier. The author provides the
 [libu8ident](https://github.com/rurban/libu8ident/) library (Apache 2
 licensed) and its generated tables to all implementors.
@@ -73,7 +72,7 @@
 as they appeared in browsers and email. Also names in C object files:
 linkers, .def files, ffi's.
 
-Implementing TR39 mixed script detection per document (C++ Header and
+Implementing TR39 mixed script detection per document (C Header and
 Source file) forbids insecure mixes of Greek with Cyrillic, dangerous
 Arabic RTL bidi attacks and most confusables. You can still write in
 your language, but then only in commonly written languages, and not
@@ -119,7 +118,8 @@
 `XID_Start`: 131876 codepoints,
 `XID_Continue`: 135053 codepoints (= `XID_Start` + 3173)
 
-See 13 "Appendix A - C23XID_Start" and 13 "Appendix B - C23XID_Continue"
+See [13 "Appendix A - C23XID_Start"](#appendix-a---c23xid_start) and
+[14 "Appendix B - C23XID_Continue"](#appendix-b---c23xid_continue)
 
 4.2 Only Recommended scripts are now allowed, Excluded and Limited_Use not
 --------------------------------------------------------------------------
@@ -170,7 +170,7 @@
 4.3 Documents with identifiers in many multiple scripts/languages will become illegal
 -------------------------------------------------------------------------------------
 
-C++23 (and C23) will follow the TR39 Security Profile 4 **Moderately
+C23 (and C23++) will follow the TR39 Security Profile 4 **Moderately
 Restrictive**, with an exception for Greek.
 
 * All identifiers in a document qualify as Single Script, or
@@ -193,8 +193,9 @@
 the base character. Also 4 Japanese KATAKANA-HIRAGANA PROLONGED SOUND
 MARK modifier letters.
 
-See 7.2 "SCX Extensions" and 7.3 "Combining marks script run detection
-for spoofing" below.
+See [7.2 "SCX Extensions"](#scx-extensions) and [7.3 "Combining marks
+script run detection for spoofing"](#combining-marks-script-run-detection-for-spoofing)
+below.
 
 5 What will this proposal not change
 ====================================
@@ -247,7 +248,7 @@
 7.1 SC
 -----
 
-C++ only needs to map unicode characters to a script property via a
+C only needs to map unicode characters to a script property via a
 single byte.  There are currently 161 scripts assigned, 32 of them are
 in common use as identifiers, hence called **Recommended** scripts. The
 rest is split up into 127-31 **Excluded** scripts, which are not in common
@@ -272,7 +273,7 @@
 Table 7, Limited Use Scripts. To avoid security issues, some
 implementations may wish to disallow the limited-use scripts in
 identifiers. For more information on usage, see the Unicode Locale
-project [CLDR](http://cldr.unicode.org/)."
+project [CLDR](http://cldr.unicode.org/)."_
 
 Regarding stability: New scripts are added on a yearly basis, but
 nothing was added to the stable set of recommended scripts. For a
@@ -314,7 +315,8 @@
 Some of the SCX scripts contain only a single script. These could be
 directly added to the list of SC scripts for the purpose of identifier
 security checks, but I advise against, for easier Combining Marks
-checks against the base character script. See below 7.3.
+checks against the base character script. See below
+[7.3](#combining-marks-script-run-detection-for-spoofing).
 
 E.g.
 
@@ -437,7 +439,7 @@
 
     grep ', U8ID_Technical' scripts.h | egrep -v 'Not_XID|U8ID_Obsolete|U8ID_Exclusion'
 
-See 17 Appendix E - IDType Technical.
+See [17 Appendix E - IDType Technical](#appendix-e---idtype-technical).
 
 9 TR39 Mixed Scripts
 ====================
@@ -465,7 +467,8 @@
 Latin letter which looks the same as the Greek counterpart, the Greek
 letter is forbidden, choose the Latin one instead. E.g.
 ( Α → A ) GREEK CAPITAL LETTER ALPHA → LATIN CAPITAL LETTER A.
-See **18 Appendix F** for the generated list with 10 exceptions.
+See [18 Appendix F](#appendix-f---greek-confusables) for the generated
+list with 10 exceptions.
 
 Thus it prevents Cyrillic mixed with Latin or any other script, but
 does allow any East-Asian CFK language, other common and widely used
@@ -487,6 +490,8 @@
              Greek confusable
 * U+03F2 ( ϲ → c ) GREEK LUNATE SIGMA SYMBOL → LATIN SMALL LETTER C
              Greek confusable
+* U+0381 ; ( α → a ) GREEK SMALL LETTER ALPHA. Not confusable
+* U+03F1 ; ( ϱ → p ) GREEK RHO SYMBOL → LATIN SMALL LETTER P. Not confusable
 
 TR39 also compiles a convenient
 [IdentifierStatus](https://www.unicode.org/Public/security/latest/IdentifierStatus.txt)
@@ -520,20 +525,19 @@
 identifiers.  One could argue that a mixed-script profile is valid
 only for a single identifier, or it is valid for the whole source file
 document. And there needs to be a definition if before or after the
-preprocessor, and if to treat names in private structs and classes as
-seperate contexts.
+preprocessor, and if to treat names in private structs as seperate
+contexts.
 
 If valid for only a single identifier you could arbitralily mix up
-Cyrillic with Greek identifiers in a C++ namespace, and thus these
+Cyrillic with Greek identifiers in a C files, and thus these
 identifiers would not be identifiable anymore, as both both can render
 to the very same glyphs. Thus we adopt the notion of identifier
 contexts.
 
 With programming languages this is a source file, with objects files
 this is a module.  For identifiers in object files see below [12
-Issues with binutils, linkers, exported identifiers](#12 Issues with
-binutils, linkers, exported identifiers). For filesystems this would
-be a directory.
+Issues with binutils, linkers, exported identifiers](#issues-with-binutils-linkers-exported-identifiers).
+For filesystems this would be a directory.
 
 For every source file we need to store a context with the list of
 already seen scripts and how many.  The maximal number of scripts is
@@ -556,14 +560,15 @@
   arabic fields, and include another header with Cyrillic only
   names. This would allow confusables in the resulting object
   file, and source files would be easy to check with external tools.
-  See also the binutils section 12 below.
+  See also the [binutils section 12](#12-issues-with-binutils-linkers-exported-identifiers)
+  below.
 
 - **private**: Another argument would be that all exported names end
   up in the object files and library flat, which would support the
   seperation of private and public name contexts, where to perform the
-  mixed-script checks. Private contexts (e.g. static structs or
-  private class fields) should be seperated from the rest.  This would
-  prevent from confusuables in struct/class fields/methods, and the
+  mixed-script checks. Private contexts (e.g. static structs fields)
+  should be seperated from the rest.  This would
+  prevent from confusables in struct fields/methods, and the
   rest is seperated by the checks for the public names.
 
 - **after-cpp**: The third, strictest variant would define the context in
@@ -607,7 +612,7 @@
 12 Issues with binutils, linkers, exported identifiers
 =====================================================
 
-The crux with C and somewhat also C++ identifiers, is that they can be
+The crux with C and somewhat also C identifiers, is that they can be
 used with other earlier compilers or languages without any unicode security
 profile or restriction. ffi's are very common, libraries or .def files
 even more, thanksfully unicode names not at all yet.
@@ -617,28 +622,29 @@
 there, and names are charset (=user) specific, whilst there are no header
 fields for the used charset (e.g. if SHIFT-JIS or UTF-8), nor are
 there any rules for name lookup (normalization). This is not solvable
-here (in C nor C++), only there. Only in the Rust ecosystem there are
-proper unicode identifier rules, but Rust can link against
-C++/C. I haven't detected any exported unicode names in the wild, they
+here (in C), only there. Only in the Rust ecosystem there are
+proper unicode identifier rules, but Rust can link against C.
+I haven't detected any exported unicode names in the wild, they
 are only used in local symbols still. UTF-16 compilers such as MSVC do
 export their UNICODE names either in the local character set or as
 UTF-8. If used wildly, object files would not link anymore, as local
 character sets vary, and there is no character set standard defined.
 
-The C++/C working groups should urge the binutils/linker working
+The C/C++ working groups should urge the binutils/linker working
 groups to adopt a more precise specification how exported identifiers
 are represented in object files and libraries: UTF-8 or any charset,
 and how they are looked up: any normalization, NFC or not at all.  My
-recommendation would be to interpret them as UTF-8, require NFC, and
-reject all illegal UTF-8 and non-NFC identifiers. As long as there no
+recommendation would be to interpret them as UTF-8, use NFC for the
+lookup, and reject all illegal UTF-8 identifiers. As long as there no
 unicode names in the wild this is still easy. There are also many
 object file producers in the wild, with possibly completely insecure
 unicode names in the future.
 
 binutils `readelf -L -Ul` is currently broken displaying unicode
 identifiers.  I have patches to display them in the current multi-byte
-locale, and to add u8ident checks with -L. I haven't found any
-violations so far in my used libraries.
+locale, and to add u8ident checks with `-L`. I haven't found any
+violations so far in my used libraries, but a Debian/Fedora/FreeBSD
+mass-scan seems necessary.
 
 Even better would be for the C ABI's to also adopt secure unicode
 identifiers, as linkers and FFI's have the same unicode security
@@ -1148,7 +1154,7 @@
 // 355 ranges, 115 singles, 99350 codepoints
 ```
 
-14 Appendix A - C23XID_Continue
+14 Appendix B - C23XID_Continue
 ===============================
 
 Created with mkc23 from libu8ident.
@@ -1963,8 +1969,9 @@
 17 Appendix E - IDType Technical
 =================================
 
-Needed for **#8 TR39 Identifier Type**. List of Technical ID characters, added
-the TR39 Recommended and Inclusion IDTypes. TR39#Table 1
+Needed for Section 8 [TR39 Identifier Type](#tr39-identifier-type).
+List of Technical ID characters, added to the TR39 Recommended and Inclusion
+IDTypes. TR39#Table 1
 <https://www.unicode.org/reports/tr39/#Identifier_Status_and_Type>
 
     grep ' Technical ' IdentifierType.txt |
@@ -2131,12 +2138,12 @@
 18 Appendix F - Greek Confusables
 =================================
 
-Needed for exclusion in the **TR39 Mixed Scripts** Greek rule. Where-ever we
-have a Greek letter confusable with Latin, and we already saw Latin, forbid
-the Greek letter in favor of the Latin letter. See TR39
+Needed for exclusion in the [9 TR39 Mixed Scripts](#tr39-mixed-scripts) Greek
+rule.  Where-ever we have a Greek letter confusable with Latin, and we already
+saw Latin, forbid the Greek letter in favor of the Latin letter. See TR39
 [confusables.txt](https://www.unicode.org/Public/security/latest/confusables.txt).
-Note that these confusables cannot be excluded upfront in the TR31 identifier parsing,
-as Greek alone is allowed.
+Note that these confusables cannot be excluded upfront in the TR31
+identifier parsing, as Greek alone is allowed.
 
 18.1 Exceptions
 ----------------
