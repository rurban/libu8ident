#!/usr/bin/env perl
# libu8ident - Check unicode security guidelines for identifiers.
# Copyright 2022 Reini Urban
# SPDX-License-Identifier: Apache-2.0
#
# Create u8id_gc.h General_Category API

use strict;
use Config;
use utf8;

my $ucd = "UnicodeData.txt";
if (!-e $ucd) {
  system("wget -N https://www.unicode.org/Public/UNIDATA/$ucd");
}

my $gc_h = "u8id_gc.h";
my (@GC, %GC);
open my $UCD, "<", $ucd or die "$ucd $!";
my ($from, $to, $oldto, $oldgc, $gc) = (0,0,0,'Cc','');
while (<$UCD>) {
  my @l = split ';';
  $gc = @l[2];
  if ($gc =~ /^\w.$/) {
    $GC{$gc}++;
    $to = hex($l[0]);
    if ($oldgc ne $gc) {
      push @GC, [$from, $to-1, $oldgc];
      $from = $to;
      $oldgc = $gc;
    }
    #else {
    #  $oldto = $GC[$#GC]->[1];
    #  # FIXME
    #  if ($oldto + 1 != $to) {
    #    push @GC, [$to, $to, $gc];
    #    $from = $to;
    #  } else { # update last
    #    $GC[$#GC]->[1] = $to;
    #  }
    #}
  }
}
push @GC, [$from, $to, $gc]; # the remainder
close $UCD;

if (!-w $gc_h) {
  chmod 0644, $gc_h;
}
open my $H, ">:utf8", $gc_h or die "writing $gc_h $!";
print $H <<'EOF';
/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/* libu8ident - Check unicode security guidelines for identifiers.
   Copyright 2022 Reini Urban
   SPDX-License-Identifier: Apache-2.0

   UCD General_Category API
   For scripts.h we are only interested for the Identifier parts in scx_list[]
   to detect illegal runs.
   But u8idlint.c/unic26.h needs the full list.
   Thanksfully this is only needed offline, to create unic26.h.
   Generated by mkgc.pl, do not modify.
*/

#include <stdint.h>

enum u8id_gc {
EOF
my @GCs = sort keys %GC;
for my $g (@GCs) {
  $g =~ s/&/amp/;
  printf $H "  GC_%s,\n", $g;
}
printf $H "  GC_L, // is L&, all letters. (for unic26.h only)\n";
printf $H "  GC_V, // is varying, eg L or S. (for unic26.h only),\n";
printf $H "  GC_INVALID,\n";
printf $H <<'EOF', scalar(@GCs) + 3;
};

#ifdef EXTERN_SCRIPTS
extern const char *const u8id_gc_names[%u];
#else
LOCAL const char *const u8id_gc_names[] = {
EOF
for my $g (@GCs) {
  $g =~ s/&/amp/;
  printf $H "  \"%s\",\n", $g;
}
printf $H "  \"L\", // L& really (for unic26.h only)\n";
printf $H "  \"V\", // varying (for unic26.h only)\n";
printf $H "  \"Zz\"\n";
printf $H <<'EOF';
};
#endif

struct gc {
  uint32_t from;
  uint32_t to;
  enum u8id_gc gc;
};

EOF

printf $H <<'EOF', scalar @GC;
#ifdef EXTERN_SCRIPTS
extern const struct gc gc_list[%u];
#else
const struct gc gc_list[] = {
    // clang-format off
EOF
for my $r (@GC) {
  my $u = chr $r->[0];
  $u = '' if $r->[0] >= 0xDB70 && $r->[0] <= 0xDFFF;
  $u = '' if $u !~ /\w/;
  $u = '' if $r->[2] =~ /^M/;
  if ($r->[0] == $r->[1]) {
    printf $H "    {0x%X, 0x%X, GC_%s},\t// %s\n", $r->[0], $r->[1], $r->[2], $u;
  } else {
    my $u1 = chr $r->[1];
    $u1 = '' if $r->[1] >= 0xD800 && $r->[1] <= 0xDFFF;
    $u1 = '' if $u !~ /\w/;
    $u1 = '' if $r->[2] =~ /^M/;
    printf $H "    {0x%X, 0x%X, GC_%s},\t// %s..%s\n", $r->[0], $r->[1], $r->[2], $u, $u1;
  }
}
printf $H <<'EOF';
    // clang-format on
};
#endif
EOF

close $H;
chmod 0444, $gc_h;
print "Created $gc_h\n";

