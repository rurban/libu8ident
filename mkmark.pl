#!/usr/bin/env perl
# libu8ident - Check unicode security guidelines for identifiers.
# Copyright 2014, 2021 Reini Urban
# SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later
#
# Create mark.h Combining_Mark (Mc | Me | Mn)

use strict;
use Config;
my $ucd = "UnicodeData.txt";
my $mark_h = "mark.h";
if (!-e $ucd) {
  system("wget -N https://www.unicode.org/Public/UNIDATA/$ucd");
  if (!-e $ucd && -e $mark_h) {
    die "Cannot download $ucd, but have $mark_h\n";
  }
}

my $doc = "doc/appendix-h.md";
my (@MARK, @NSM, %NSM);
open my $UCD, "<", $ucd or die "$ucd $!";
my ($from, $to, $oldto);
while (<$UCD>) {
  my @l = split ';';
  my $mark = $l[2];
  if ($mark =~ /^M[cen]$/) {
    $to = hex($l[0]);
    if (!$from) {
      push @MARK, [$to, $to];
      $from = $to;
    } else {
      $oldto = $MARK[$#MARK]->[1];
      if ($oldto + 1 != $to) {
        push @MARK, [$to, $to];
        $from = $to;
      } else { # update last
        $MARK[$#MARK]->[1] = $to;
      }
    }
    my $name = $l[1];
    my $n = $l[10];
    if ($name =~ /^COMBINING / && $l[4] eq 'NSM' && $n =~ /^NON-SPACING /) {
      $n =~ s/^NON-SPACING //;
      my $nsm = $n;
      push @NSM, [ $nsm, $to ];
    }
  }
}
# $NSM{'DOT ABOVE'} = [ ord('i') ];
seek($UCD,0,0);
while (<$UCD>) {
  my @l = split ';';
  my $name = $l[1];
  # Check "HIRAGANA LETTER PA;Lo;0;L;306F 309A;" NFD expansion
  if ($l[2] =~ /^L/ && $l[5] =~ / /) {
    for my $r (@NSM) {
      my $nsm = $r->[0];
      my $n = sprintf("%04X", $r->[1]);
      if ($l[5] =~ / \Q$n\E$/) {
        my $cp = hex $l[0];
        if (exists $NSM{$nsm}) {
          push @{$NSM{$nsm}}, $cp;
        } else {
          $NSM{$nsm} = [ $cp ];
        }
      }
    }
  }
  # but also check names with NSM's, e.g. LATIN SMALL LETTER Q WITH HOOK
  # without any NFD expansion. => DOT ABOVE, DIAERESIS, DOT BELOW, THREE DOTS ABOVE,
  # FOUR DOTS ABOVE.
  elsif ($name =~ /LETTER .+ WITH .+/) {
    for my $r (@NSM) {
      my $nsm = $r->[0];
      if ($name =~ /LETTER .+ WITH \Q$nsm\E$/) {
        my $cp = hex $l[0];
        if (exists $NSM{$nsm}) {
          push @{$NSM{$nsm}}, $cp;
        } else {
          $NSM{$nsm} = [ $cp ];
        }
      }
    }
  }
  # plus all the DOTLESS i and j letters, but not arabic BEH, NOON, FEH, QAF
  if ($name =~ /LETTER .+ DOTLESS [IJ]/) {
    my $nsm = 'DOT ABOVE';
    my $cp = hex $l[0];
    #if (exists $NSM{$nsm}) {
    push @{$NSM{$nsm}}, $cp;
    #} else {
    #  $NSM{$nsm} = [ $cp ];
    #}
  }
}
close $UCD;
# delete empty NSM's
my $NUM_NSM = scalar @NSM;
my @N;
for my $r (@NSM) {
  if (exists $NSM{$r->[0]}) {
    push @N, $r;
  } else {
    warn "skip empty $r->[0] ",sprintf("%04X",$r->[1]),"\n";
  }
}
@NSM = @N;

chmod 0644, $mark_h if !-w $mark_h;
chmod 0644, $doc if !-w $doc;
open my $H, ">encoding(UTF-8)", $mark_h or die "writing $mark_h $!";
open my $DOC, ">encoding(UTF-8)", $doc or die "writing $doc $!";
print $H <<'EOF';
/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/* libu8ident - Check unicode security guidelines for identifiers.
   Copyright 2014, 2021, 2022 Reini Urban
   SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later

   All Combining_Mark (Mc | Me | Mn),
   All letters with non-spacing combining marks.
   Generated by mkmark.pl, do not modify.
*/
#include <stdint.h>
#include <wchar.h>

struct nsm_ws {
    uint32_t nsm;
    wchar_t  *letters;
};

EOF
print $DOC <<EOF;
20 Appendix H - Letters with non-spacing marks
==============================================
EOF

printf $H <<'EOF', scalar @MARK;
/* All Combining Marks, sorted */
#ifdef EXTERN_SCRIPTS
extern const struct range_bool mark_list[%u];
#else
const struct range_bool mark_list[] = {
    // clang-format off
EOF
for my $r (@MARK) {
  printf $H "    { 0x%X, 0x%X },\n", $r->[0], $r->[1];
}
printf $H <<'EOF';
    // clang-format on
};
#endif
EOF

printf $H <<'EOF';

/* All non-spacing combining marks, sorted */
enum nsm_marks {
EOF
for my $r (@NSM) {
  my $n = $r->[0];
  $n =~ s/[ -]/_/g;
  printf $H "    NSM_%s,\t/* %X */\n", $n, $r->[1];
}
printf $H <<'EOF';
    NSM_LAST
};
EOF

printf $H <<'EOF', scalar @NSM;

/* All letters with non-spacing combining marks, sorted.
   The first entry is the NSM, if letters exist.
 */
#ifdef EXTERN_SCRIPTS
extern const struct nsm_ws nsm_letters[%u];
#else
const struct nsm_ws nsm_letters[] = {
    // clang-format off
EOF
printf $DOC <<'EOF', $NUM_NSM, scalar @NSM;

From all %u non-spacing marks,
the list of letters already including its %u non-spacing marks:

EOF

for my $r (@NSM) {
  my $nsm = $r->[0];
  printf $H "    { ";
  if ($NSM{$nsm}) {
    my $u = "";
    if ($r->[1] >= 0x10000) {
      printf $H "0x%05X,  /* NSM: %s %X */\n      ", $r->[1], $nsm, $r->[1];
      printf $DOC "- NSM: %s %05X\n\n    ", $nsm, $r->[1];
    } else {
      printf $H "0x%04X,  /* NSM: %s %X */\n      ", $r->[1], $nsm, $r->[1];
      printf $DOC "- NSM: %s %04X\n\n    ", $nsm, $r->[1];
    }
    printf $H "L\"";
    my $i = 0;
    my @L = @{$NSM{$nsm}};
    for (@L) {
      if ($_ != 0) {
        $u .= chr ($_);
        if ($_ >= 0x10000) {
          printf $H "\\U%08X", $_;
          printf $DOC "%05X", $_;
        } else {
          printf $H "\\u%04X", $_;
          printf $DOC "%04X", $_;
        }
        if (@L == $i + 1) {
            print $DOC "\n";
        } else {
          print $DOC ++$i % 8 ? ", " : "\n    ";
        }
      } else {
        warn "0 in $nsm";
      }
    }
    printf $H "\" },\n      /* %s */\n", $u;
    printf $DOC "\n  \"%s\"\n", $u;
    printf $DOC "\n";
  } else {
    printf $H "0U },    /* NSM: %s %X */\n", $nsm, $r->[1];
    printf $DOC "None\n";
  }
}
printf $H <<'EOF';
    // clang-format on
};
#endif
EOF

# assume symlinked
if (-e "roaring.h" && -e "roaring.c") {
    print "\nCreate serialized roaring bitmaps:\n";
    if ($^O =~ /Win32/) {
	system($Config{cc}." mkroar.c -I. -o mkroar.exe");
	system("mkroar.exe mark");
	# ignore vms for now
    } else {
	system($Config{cc}." mkroar.c -I. -o mkroar");
	system("./mkroar mark");
    }
    print "\n";
    my $c = "mark_croar";
    print $H <<'EOF';

// This was just an experiment. It's slower than binary search in ranges.
#ifdef HAVE_CROARING
#  ifndef EXTERN_SCRIPTS
/* generated via mkroar.c */
EOF
    close $H;
    system("xxd -i $c.bin >> $mark_h");
    unlink "$c.bin";
    open $H, ">>", $mark_h or die "appending $mark_h $!";
    print $H <<'EOF';
#  else
extern const unsigned int mark_croar_bin_len;
extern const unsigned char mark_croar_bin[1219]; // checkme on updates
#  endif // EXTERN_SCRIPTS
#endif // HAVE_CROARING
EOF
}

close $H;
close $DOC;
chmod 0444, $mark_h;
chmod 0444, $doc;
print "Created mark.h and $doc\n";

