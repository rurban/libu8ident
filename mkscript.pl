#!/usr/bin/env perl
# libu8ident - Follow unicode security guidelines for identifiers.
# Copyright 2014, 2021 Reini Urban
# SPDX-License-Identifier: Apache-2.0
#
# Classify and search for the script property https://www.unicode.org/reports/tr24/tr24-32.html
# Implement http://www.unicode.org/reports/tr39/#Mixed_Script_Detection

use strict;
my $scn = "Scripts.txt";
my $scxn = "ScriptExtensions.txt";
if (!-e $scn) {
  system("wget -N https://www.unicode.org/Public/UNIDATA/Scripts.txt");
}
if (!-e $scxn) {
  system("wget -N https://www.unicode.org/Public/UNIDATA/ScriptExtensions.txt");
}

# http://www.unicode.org/reports/tr31/#Table_Recommended_Scripts
my @recommended = qw(
  Common Inherited Latin Arabic Armenian Bengali Bopomofo Cyrillic
  Devanagari Ethiopic Georgian Greek Gujarati Gurmukhi Hangul Han Hebrew
  Hiragana Katakana Kannada Khmer Lao Malayalam Myanmar Oriya
  Sinhala Tamil Telugu Thaana Thai Tibetan);

#All Limited Use Scripts are disallowed:
#http://www.unicode.org/reports/tr31/#Table_Limited_Use_Scripts
my @limited = qw(
  Adlam Balinese Bamum Batak Canadian_Aboriginal Chakma Cham Cherokee
  Hanifi_Rohingya Javanese Kayah_Li Lepcha Limbu Lisu Mandaic
  Meetei_Mayek Miao New_Tai_Lue Newa Nko Nyiakeng_Puachue_Hmong Ol_Chiki
  Osage Saurashtra Sundanese Syloti_Nagri Syriac Tai_Le Tai_Tham
  Tai_Viet Tifinagh Vai Wancho Yi Unknown);
open my $SC, "<", $scn or die "$scn $!";
my (@ucd_version, $started, $from, $to, $sc, $oldto, $oldsc,
    @SC, @SCR, @SCRF, @SCXR, %SC, %scripts, $sc);
while (<$SC>) {
  if (!$started && /^# Scripts-(\d+)\.(\d+)\.(\d+)\.txt/) {
    @ucd_version = ($1, $2, $3);
  }
  if (/^0000/) { $started++; }
  next unless $started;
  if (/^([0-9A-F]{4,5})\.\.([0-9A-F]{4,5})\s+; (\w+) #/) {
    ($from, $to, $sc) = (hex($1), hex($2), $3);
  }
  elsif (/^([0-9A-F]{4,5})\s+; (\w+) #/) {
    ($from, $to, $sc) = (hex($1), hex($1), $2);
  } else {
    #warn $_;
    next;
  }
  # only if the Sc is new or there is a hole
  if (($from != $oldto + 1) or ($oldsc ne $sc)) { 
    push @SCR, [$from, $to, $sc];
    $scripts{$sc}++;
    $oldsc = $sc;
  } else { # update the range
    my $range = $SCR[$#SCR];
    $range->[1] = $to;
    $SCR[$#SCR] = $range;
  }
  $oldto = $to;
}
close $SC;
$started = 0;
$oldto = 0; $oldsc = "";
open my $SCX, "<", $scxn or die "$scxn $!";
my $scl;
while (<$SCX>) {
  if (/^# Script_Extensions=/) { $started++; }
  next unless $started;
  if (/^([0-9A-F]{4,5})\.\.([0-9A-F]{4,5})\s+; ([\w ]+) #/) {
    ($from, $to, $scl) = (hex($1), hex($2), $3);
  }
  elsif (/^([0-9A-F]{4,5})\s+; ([\w ]+) #/) {
    ($from, $to, $scl) = (hex($1), hex($1), $2);
  } else {
    #warn $_;
    next;
  }
  # only if the Sc is new or there is a hole
  if (($from != $oldto + 1) or ($oldsc ne $scl) or !@SCXR) {
    # scl is a list of short script names
    push @SCXR, [$from, $to, $scl];
    $oldsc = $scl;
  } else { # update the range
    my $range = $SCXR[$#SCXR];
    $range->[1] = $to;
    $SCXR[$#SCXR] = $range;
  }
  $oldto = $to;
}
close $SCX;

my $num_scripts = scalar keys %scripts;
printf "%d SC ranges, %d unique scripts", scalar @SCR, $num_scripts;
printf ", %d SCX ranges\n", scalar @SCXR;
die if $num_scripts > 255;

# sort the scripts by ->from
@SCR = sort { $a->[0] <=> $b->[0] } @SCR;
@SCXR = sort { $a->[0] <=> $b->[0] } @SCXR;

$oldto = 0;
# Collapse neighbors, generate a fast SCRF variant without holes.
my @_SCR;
undef $oldsc;
my $oldscf;
for my $r (@SCR) {
  ($from, $to, $sc) = ($r->[0], $r->[1], $r->[2]);
  # the full list, with all holes
  if (($from != $oldto + 1) or ($oldsc ne $sc)) { # honor holes
    push @_SCR, [$from, $to, $sc];
    $oldsc = $sc;
  } else { # update the range
    my $range = $_SCR[$#_SCR];
    $range->[1] = $to;
    $_SCR[$#_SCR] = $range;
  }
  $oldto = $to;
  # now the faster variant
  if ($oldscf ne $sc or !@SCRF) { # ignore holes
    push @SCRF, [$from, $to, $sc];
    $oldscf = $sc;
  } else { # update the range
    my $range = $SCRF[$#SCRF];
    $range->[1] = $to;
    $SCRF[$#SCRF] = $range;
  }
}
@SCR = @_SCR;

open my $H, ">", "scripts.h" or die "writing scripts.h $!";
print $H <<"EOF";
/* ex: set ro ft=c: -*- mode: c; buffer-read-only: t -*- */
/* libu8ident - Follow unicode security guidelines for identifiers.
   Copyright 2014, 2021 Reini Urban
   SPDX-License-Identifier: Apache-2.0

   generated by mkscripts.pl, do not modify.
*/

struct sc {
  uint32_t from;
  uint32_t to;
  uint8_t  scr; // index
};

struct scx {
  uint32_t from;
  uint32_t to;
  uint8_t *list; // indices
};

/* Provide a mapping of the $num_scripts Script properties to an index byte.
   Sorted into usages.
 */
const char* const all_scripts[] = {
#define FIRST_RECOMMENDED_SCRIPT 0
EOF
my $i = 0;
for my $sc (@recommended) {
  my $ws = " " x (10-length($sc));
  $SC{$sc} = $i;
  printf $H "#define SC_%s%s %d\n", $sc, $ws, $i;
  printf $H "  \"%s\",\n", $sc, $i;
  $i++;
}
print $H <<"EOF";
#define FIRST_NOT_RECOMMENDED_SCRIPT $i
  // Not Recommended Scripts (but can to be declared expliclitly)
EOF
my %other = map {$_ => 1} @recommended, @limited;
for my $sc (sort keys %scripts) {
  unless ($other{$sc}) {
    my $ws = " " x (10-length($sc));
    $SC{$sc} = $i;
    printf $H "#define SC_%s%s %d\n", $sc, $ws, $i;
    printf $H "  \"%s\",\n", $sc, $i;
    $i++;
  }
}
print $H <<"EOF";
#define FIRST_LIMITED_USE_SCRIPT $i
  // Limited Use Scripts
EOF
for my $sc (@limited) {
  my $ws = " " x (10-length($sc));
  $SC{$sc} = $i;
  printf $H "#define SC_%s%s %d\n", $sc, $ws, $i;
  printf $H "  \"%s\",\n", $sc, $i;
  $i++;
}
$i--;
print $H <<"EOF";
#define LAST_SCRIPT $i
};

#ifndef DISABLE_CHECK_XID
// The slow variant for U8ID_CHECK_XID. Add all holes for non-identifiers or non-codepoints.
const struct sc xid_script_list[] = {
EOF
for my $r (@SCR) {
  printf $H "  {0x%04X, 0x%04X, %d},\t// %s\n", $r->[0], $r->[1], $SC{$r->[2]}, $r->[2];
};
print $H <<"EOF";
};
#endif

// The fast variant without U8ID_CHECK_XID. No holes for non-identifiers or non-codepoints needed,
// as the parser already disallowed such codepoints.
const struct sc nonxid_script_list[] = {
EOF
for my $r (@SCRF) {
  printf $H "  {0x%04X, 0x%04X, %d},\t// %s\n", $r->[0], $r->[1], $SC{$r->[2]}, $r->[2];
};
print $H <<"EOF";
};

// FIXME SCX list
const struct scx scriptx_list[] = {
EOF
for my $r (@SCXR) {
  printf $H "  {0x%04X, 0x%04X, \"%s\"},\t// %s\n", $r->[0], $r->[1], $r->[2], $r->[2];
};
print $H <<"EOF";
};
EOF

close $H;

# patch our header
my $inc = "include/u8ident.h";
open my $INC, "<", $inc or die "$inc $!";
while (<$INC>) {
  if (/^#define U8IDENT_UNICODE_VERSION (\d+)/) {
    my $version = $1;
    if ($version != $ucd_version[0]) {
      close $INC;
      patch_ucd_major($inc, $ucd_version[0]);
      last;
    }
  }
}
close $INC;

sub patch_ucd_major {
  my ($inc, $version) = @_;
  open my $OLD, "<", $inc or die "$inc $!";
  open my $NEW, ">", "$inc.new" or die "$inc.new $!";
  while (<$INC>) {
    if (/^(#define U8IDENT_UNICODE_VERSION )(\d+)/) {
      print $NEW "$1 $version\n";
    } else {
      print $NEW $_;
    }
  }
  close $OLD, $NEW;
  rename $inc, "$inc.bak";
  rename "$inc.new", $inc;
}

